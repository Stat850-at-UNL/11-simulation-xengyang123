---
title: "simulation"
format: html
editor: visual
author: "Xeng Yang worked with Nicole H. and Dhunuska B."
---

```{r include=FALSE, echo=FALSE}
library(dplyr)

################ helper functions #################

roll_dice <- function() {
  # Input: None
  # Output: an integer from 1:12
  # Description: Generate 2 random integers from 1 to 6 and sum them
  
  sample(1:6, 2, replace = T) %>% sum()
}

appendVectors <- function(roll,outcome,df) { 
# Input: Die roll and outcome 
# Output: appended vectors.
# Description: appends id, roll, and outcome vectors with information for the most recent roll.
  
  newRow <- data.frame(nrow(df)+1,roll,outcome)
  names(newRow) <- c("id","roll","outcome")
  df <- rbind(df,newRow)
  
  return(df)
}

comeOut <- function(roll,df){
# Input: Die roll 
# Output: win/loss message
# Description: if the come out roll was a 7 or 11, the code displays a win message and returns a data frame. if the come out roll was a 2, 3 or 12, the function displays a lose message and returns a data frame. note in both cases, info from the roll is appended to the respective vectors (id,roll,outcome), which then are combined into the data frame that is returned in both cases.  
  
  if (roll %in% c(7,11)) {
    df <-appendVectors(roll,"Win",df)
    return(df)
  } else {
    df <-appendVectors(roll,"Lose",df)
    return(df)
  }
}

pointRoll <- function(roll,df){
# Input: Die roll 
# Output: win/loss message
# Description: code sets the point roll as equal to the die roll. info from the first roll is appended to the respective vectors (id, roll, outcome). the code uses the roll_die() function to roll again. if a 7 is rolled, info is appended to the vectors, a lose message is displayed, and the vectors are appended into a data frame that is also returned. the point is rolled, roll info is appended to the vectors, a win message is displayed, and the vectors are appended into a data frame that gets returned.this function is repeated until either a 7 or point is rolled.
    
  
  # set point 
  point <- roll
  
  # roll until either a 7 or the point is rolled
  repeat {
    df <- appendVectors(roll,"Continue",df)
    roll <- roll_dice()
    
    # check if new roll is a seven or the point is roll
    if (roll == 7) {
      df <- appendVectors(roll,"Lose",df)
      return(df)
    } else if(roll == point){
      df <- appendVectors(roll,"Win",df)
      return(df)
    }
  }
}

################ main functions #################

simulate_craps_game <- function() {
  # Input: 
  # Output: 
  # Description:
  
  # set up empty data frame
  df <- data.frame()
  
  # come out roll
  first_roll <- roll_dice()
  
  # evaluate first_roll
  if (first_roll %in% c(2,3,7,11,12)) {
    comeOut(first_roll,df)
  } else {
    pointRoll(first_roll,df)
  }
}

summarize_craps_game <- function(df) {
  # Input: data frame from a simulated craps game
  # Output: a single row of data summarizing the game
  # Description: this function takes in the data frame from a single game of craps and summarizes it. the summary includes the number of rolls in the game, whether the game was won or lost, and the point, if applicable

  if (nrow(df) == 1) {
    df <- data.frame(nrow(df),df[1,2],df[nrow(df),3],"NA")
    names(df) <- c("number_of_rolls","first_roll","game_outcome","point") 
  } else{
    df <- data.frame(nrow(df),df[1,2],df[nrow(df),3],df[1,2])
    names(df) <- c("number_of_rolls","first_roll","game_outcome","point") 
  }
  return(df)
}

run_craps_simulation <- function(N) {
  # Input: an integer N which determines the number of games to simulate
  # Output: a dataframe containing the outcomes of the simulated games
  # Description:
  
  # set up empty data frame to be returned
  df <- data.frame()
  
  # append rows to the data frame until the data frame equals N
  repeat{
    summaryGame <- summarize_craps_game(simulate_craps_game())
    df <- rbind(df,summaryGame)
    
    if (nrow(df) == N) {
      return(df)
    }
  }
}
```

Below are graphics for the simulated data. I only simulated 1,000 games because my computer is old and couldn't handle much more than that... :\]

```{r echo=FALSE}
sim <- run_craps_simulation(1000)

library(ggplot2)

ggplot(sim, aes(x = number_of_rolls)) + 
  geom_bar(fill = "turquoise") +
  xlab("Number of Rolls")
```

```{r echo=FALSE}
sim$first_roll <- factor(sim$first_roll)

ggplot(sim, aes(x = first_roll)) + 
  geom_bar(fill = "purple") +
  xlab("Number of the First Roll")
```

This plot displays the game outcome based on the number of rolls a game had. Notice that games with one roll had a significantly higher probability of a win, but generally games with more than one roll had a higher chance of losing.

```{r echo=FALSE}
# plot displaying game outcome based on # of rolls
ggplot(sim, aes(x = number_of_rolls, fill = game_outcome)) + 
  geom_bar(position = 'dodge') +
  xlab("Number of Rolls") +
  guides(fill=guide_legend(title="Game Outcome"))
```

I chose to simulate the probability of winning on a don't pass line bet. A don't pass line bet wins if a 2, 3, or 12 is rolled on the first roll. In other words, this bet wins if the player loses on the come out roll.

```{r}
library(dplyr)
dpl <- sim %>%
  filter(number_of_rolls == 1 & game_outcome == "Lose")
 
prob <- nrow(dpl)/nrow(sim)
prob
```

Then, I created a for loop to generate 9 more data sets of 1,000 simulations, compute the bet percentage, and display the results in a list.

```{r}
probVector <- c()
for (x in 1:9) {
  sim <- run_craps_simulation(1000)
  dpl <- sim %>%
    filter(number_of_rolls == 1 & game_outcome == "Lose")
  prob <- nrow(dpl)/nrow(sim)
  probVector <- append(probVector,prob)
}
```

The standard deviation for the ten data sets is about 0.01, which is not much variation for 1,000 games. I would guess the standard deviation would be even smaller had I simulated 10,000 games instead of just 1,000.

```{r}
probVector
var <- sd(c(prob,probVector))
var
```
